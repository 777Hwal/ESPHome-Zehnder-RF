substitutions:
  name: "ventilation"
  friendly_name: Ventilation

esphome:
  name: ${name}
  comment: ${friendly_name}

esp32:
  board: esp32doit-devkit-v1
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: "YwH03VM9GnVi6tagb7dIFqx9tFdymUCYUfomol2oaFg="

# OTA updates (simplified form)
ota:
  - platform: esphome
    password: !secret esphome_utility_bridge_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none   
  manual_ip:
    static_ip: 192.168.178.208
    gateway: 192.168.178.1
    subnet: 255.255.255.0  

  ap:
    ssid: "Ventilation Fallback"
    password: !secret esphome_utility_bridge_ap_password

# Just for testing, now comment out    
# web_server:
#  port: 80
#    auth:
#    username: !secret web_server_username
#    password: !secret web_server_password

captive_portal:

time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: Europe/Amsterdam

external_components:
  - source: github://777Hwal/ESPHome-Zehnder-RF

#  - source:
#      type: local
#      path: components

# SPI
spi:
  clk_pin: GPIO14
  mosi_pin: GPIO13
  miso_pin: GPIO12

# nRF905 config
nrf905:
  id: "nrf905_rf"
  cs_pin: GPIO15
  cd_pin: GPIO33
  ce_pin: GPIO27
  pwr_pin: GPIO26
  txen_pin: GPIO25

# The FAN controller
fan:
  - platform: zehnder
    id: zehnder_fan
    name: "Ventilation"
    nrf905: nrf905_rf
    update_interval: 60s

globals:
  # Countdown timer in minutes, used for timed speed modes
  - id: countdown_timer
    type: int
    initial_value: '0'

  # Track the requested speed separately, so we can rebroadcast if needed
  - id: requested_speed
    type: int
    initial_value: '1'

  # Flag to indicate whether the last change originated locally (this device)
  # true  = local change → we rebroadcast every 5s if mismatch
  # false = external change → we adopt external speed, sync UI, and start timers
  - id: local_change
    type: bool
    initial_value: 'false'

interval:
  # Every 60 seconds → decrement the countdown timer and end timed mode when it hits zero
  - interval: 60s
    then:
      lambda: |-
        if (id(countdown_timer) > 0) {
          id(countdown_timer) -= 1;
          if (id(countdown_timer) == 0) {
            // Timer finished → return to Speed 1 locally
            id(requested_speed) = 1;
            id(local_change) = true;   // this device initiates the change
            id(zehnder_fan).setSpeed(1);
            id(fan_speed_select).publish_state("Speed 1");
          }
        }

  # Every 5 seconds → either rebroadcast local speed or adopt external changes and start timers
  - interval: 5s
    then:
      lambda: |-
        int actual_speed = id(zehnder_fan).speed;

        if (id(local_change)) {
          // Local-origin change: enforce our requested speed by rebroadcasting
          if (actual_speed != id(requested_speed)) {
            id(zehnder_fan).setSpeed(id(requested_speed));
            ESP_LOGW("fan", "Rebroadcasting speed %d due to mismatch", id(requested_speed));
          }
          else {
          id(local_change) = false;
          }
        } else {
          // External-origin change: adopt the device's actual speed, start timers as needed, and sync UI
          if (actual_speed != id(requested_speed)) {
            id(requested_speed) = actual_speed;

            // Start appropriate timers for external changes
            if (actual_speed == 1) {
              id(countdown_timer) = 0;
              id(fan_speed_select).publish_state("Speed 1");
              ESP_LOGI("fan", "External change → Speed 1, No timer active");
            } else if (actual_speed == 2) {
              // External Speed 2 → default timed 120 minutes
              id(countdown_timer) = 120;
              id(fan_speed_select).publish_state("Speed 2");
              ESP_LOGI("fan", "External change → Speed 2, timer started (120 min)");
            } else if (actual_speed == 3) {
              // External Speed 3 → default timed 120 minutes (cannot distinguish High 10/30 externally)
              id(countdown_timer) = 120;
              id(fan_speed_select).publish_state("Speed 3");
              ESP_LOGI("fan", "External change → Speed 3, timer started (120 min)");
            } else {
              // Unknown speeds: just sync without timer
              id(countdown_timer) = 0;
              ESP_LOGW("fan", "External change → Unknown speed %d, no timer set", actual_speed);
            }
          }
        }

select:
  # Dropdown menu for selecting fan speed
  # Note: Speed 2 and Speed 3 are always timed for 120 minutes
  - platform: template
    name: "Fan Speed Control"
    id: fan_speed_select
    optimistic: true
    options:
      - "Speed 1"
      - "Speed 2"
      - "Speed 3"
      - "High 10 min"
      - "High 30 min"
    initial_option: "Speed 1"
    set_action:
      - lambda: |-
          // Mark this as a local-origin change
          id(local_change) = true;

          // Handle each option and set speed + timer accordingly
          if (x == "Speed 1") {
            id(requested_speed) = 1;
            id(zehnder_fan).setSpeed(1);
            id(countdown_timer) = 0;

          } else if (x == "Speed 2") {
            // Always timed for 120 minutes
            id(requested_speed) = 2;
            id(zehnder_fan).setSpeed(2, 120);
            id(countdown_timer) = 120;

          } else if (x == "Speed 3") {
            // Always timed for 120 minutes
            id(requested_speed) = 3;
            id(zehnder_fan).setSpeed(3, 120);
            id(countdown_timer) = 120;

          } else if (x == "High 10 min") {
            id(requested_speed) = 3;
            id(zehnder_fan).setSpeed(3, 10);
            id(countdown_timer) = 10;

          } else if (x == "High 30 min") {
            id(requested_speed) = 3;
            id(zehnder_fan).setSpeed(3, 30);
            id(countdown_timer) = 30;
          }

text_sensor:
  # Human-readable timer status
  - platform: template
    name: "Timer"
    id: timer
    lambda: |-
      if (id(requested_speed) == 1 || id(countdown_timer) == 0) {
        // Hide timer when Speed 1 or no countdown is active
        return std::string("No timer active");
      } else {
        char buffer[64];
        sprintf(buffer, "Remaining: %d min", id(countdown_timer));
        return std::string(buffer);
      }
    update_interval: 5s
